/*
 * generated by Xtext 2.29.0
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.services.SparrowGrammarAccess;
import org.xtext.example.mydsl.sparrow.AdditionExpression;
import org.xtext.example.mydsl.sparrow.Address;
import org.xtext.example.mydsl.sparrow.AllNumber;
import org.xtext.example.mydsl.sparrow.AndOrCondition;
import org.xtext.example.mydsl.sparrow.AndOrOperationLink;
import org.xtext.example.mydsl.sparrow.BeforePoint;
import org.xtext.example.mydsl.sparrow.CompareString;
import org.xtext.example.mydsl.sparrow.Condition;
import org.xtext.example.mydsl.sparrow.ConditionLink;
import org.xtext.example.mydsl.sparrow.ContractMessage;
import org.xtext.example.mydsl.sparrow.DATE;
import org.xtext.example.mydsl.sparrow.Duration;
import org.xtext.example.mydsl.sparrow.ElseExpression;
import org.xtext.example.mydsl.sparrow.ExclusiveExpression;
import org.xtext.example.mydsl.sparrow.FailResult;
import org.xtext.example.mydsl.sparrow.FloatExpression;
import org.xtext.example.mydsl.sparrow.GetPeriodExpression;
import org.xtext.example.mydsl.sparrow.Group;
import org.xtext.example.mydsl.sparrow.Initialize;
import org.xtext.example.mydsl.sparrow.Message;
import org.xtext.example.mydsl.sparrow.MixExpression;
import org.xtext.example.mydsl.sparrow.Model;
import org.xtext.example.mydsl.sparrow.Now;
import org.xtext.example.mydsl.sparrow.ObjectExpress;
import org.xtext.example.mydsl.sparrow.ObjectExpression;
import org.xtext.example.mydsl.sparrow.OperateLink;
import org.xtext.example.mydsl.sparrow.Operation;
import org.xtext.example.mydsl.sparrow.OtherExpression;
import org.xtext.example.mydsl.sparrow.OtherMixExpression;
import org.xtext.example.mydsl.sparrow.ParallelExpression;
import org.xtext.example.mydsl.sparrow.PeriodExpression;
import org.xtext.example.mydsl.sparrow.PersonExpression;
import org.xtext.example.mydsl.sparrow.RegularRuleExpression;
import org.xtext.example.mydsl.sparrow.Require;
import org.xtext.example.mydsl.sparrow.Right;
import org.xtext.example.mydsl.sparrow.RuleExpression;
import org.xtext.example.mydsl.sparrow.RuleStructure;
import org.xtext.example.mydsl.sparrow.RuleTimeExpression;
import org.xtext.example.mydsl.sparrow.SingleCondition;
import org.xtext.example.mydsl.sparrow.SingleLinkCondition;
import org.xtext.example.mydsl.sparrow.SparrowPackage;
import org.xtext.example.mydsl.sparrow.StringExpression;
import org.xtext.example.mydsl.sparrow.SubExpression;
import org.xtext.example.mydsl.sparrow.Subject;
import org.xtext.example.mydsl.sparrow.SubjectExpress;
import org.xtext.example.mydsl.sparrow.SubjectExpression;
import org.xtext.example.mydsl.sparrow.ThenOperation;
import org.xtext.example.mydsl.sparrow.ThisBoolean;
import org.xtext.example.mydsl.sparrow.ThisDate;
import org.xtext.example.mydsl.sparrow.ThisDecimal;
import org.xtext.example.mydsl.sparrow.ThisString;
import org.xtext.example.mydsl.sparrow.TimeSub;
import org.xtext.example.mydsl.sparrow.TotalCondition;
import org.xtext.example.mydsl.sparrow.TotalExpression;
import org.xtext.example.mydsl.sparrow.TotalOperation;
import org.xtext.example.mydsl.sparrow.WithinPoint;
import org.xtext.example.mydsl.sparrow.changeAddress;
import org.xtext.example.mydsl.sparrow.changeContract;
import org.xtext.example.mydsl.sparrow.changeOther;
import org.xtext.example.mydsl.sparrow.changeRule;
import org.xtext.example.mydsl.sparrow.changeString;
import org.xtext.example.mydsl.sparrow.checkExpression;
import org.xtext.example.mydsl.sparrow.everyMessage;
import org.xtext.example.mydsl.sparrow.initExpressiono;
import org.xtext.example.mydsl.sparrow.initExpressions;
import org.xtext.example.mydsl.sparrow.isDone;
import org.xtext.example.mydsl.sparrow.isTime;
import org.xtext.example.mydsl.sparrow.isTrue;
import org.xtext.example.mydsl.sparrow.keyvalue;
import org.xtext.example.mydsl.sparrow.logic;
import org.xtext.example.mydsl.sparrow.messageExpression;
import org.xtext.example.mydsl.sparrow.otherchange;
import org.xtext.example.mydsl.sparrow.setDateExpression;
import org.xtext.example.mydsl.sparrow.transferExpression;
import org.xtext.example.mydsl.sparrow.url;

@SuppressWarnings("all")
public class SparrowSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SparrowGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SparrowPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SparrowPackage.ADDITION_EXPRESSION:
				sequence_AdditionExpression(context, (AdditionExpression) semanticObject); 
				return; 
			case SparrowPackage.ADDRESS:
				sequence_Address(context, (Address) semanticObject); 
				return; 
			case SparrowPackage.ALL_NUMBER:
				sequence_AllNumber(context, (AllNumber) semanticObject); 
				return; 
			case SparrowPackage.AND_OR_CONDITION:
				sequence_AndOrCondition(context, (AndOrCondition) semanticObject); 
				return; 
			case SparrowPackage.AND_OR_OPERATION_LINK:
				sequence_AndOrOperationLink(context, (AndOrOperationLink) semanticObject); 
				return; 
			case SparrowPackage.BEFORE_POINT:
				sequence_BeforePoint(context, (BeforePoint) semanticObject); 
				return; 
			case SparrowPackage.COMPARE_STRING:
				sequence_CompareString(context, (CompareString) semanticObject); 
				return; 
			case SparrowPackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case SparrowPackage.CONDITION_LINK:
				sequence_ConditionLink(context, (ConditionLink) semanticObject); 
				return; 
			case SparrowPackage.CONTRACT_MESSAGE:
				sequence_ContractMessage(context, (ContractMessage) semanticObject); 
				return; 
			case SparrowPackage.DATE:
				sequence_DATE(context, (DATE) semanticObject); 
				return; 
			case SparrowPackage.DURATION:
				sequence_Duration(context, (Duration) semanticObject); 
				return; 
			case SparrowPackage.ELSE_EXPRESSION:
				sequence_ElseExpression(context, (ElseExpression) semanticObject); 
				return; 
			case SparrowPackage.EXCLUSIVE_EXPRESSION:
				sequence_ExclusiveExpression(context, (ExclusiveExpression) semanticObject); 
				return; 
			case SparrowPackage.FAIL_RESULT:
				sequence_FailResult(context, (FailResult) semanticObject); 
				return; 
			case SparrowPackage.FLOAT_EXPRESSION:
				sequence_FloatExpression(context, (FloatExpression) semanticObject); 
				return; 
			case SparrowPackage.GET_PERIOD_EXPRESSION:
				sequence_GetPeriodExpression(context, (GetPeriodExpression) semanticObject); 
				return; 
			case SparrowPackage.GROUP:
				sequence_Group(context, (Group) semanticObject); 
				return; 
			case SparrowPackage.INITIALIZE:
				sequence_Initialize(context, (Initialize) semanticObject); 
				return; 
			case SparrowPackage.MESSAGE:
				sequence_Message(context, (Message) semanticObject); 
				return; 
			case SparrowPackage.MIX_EXPRESSION:
				sequence_MixExpression(context, (MixExpression) semanticObject); 
				return; 
			case SparrowPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case SparrowPackage.NOW:
				sequence_Now(context, (Now) semanticObject); 
				return; 
			case SparrowPackage.OBJECT:
				sequence_Object(context, (org.xtext.example.mydsl.sparrow.Object) semanticObject); 
				return; 
			case SparrowPackage.OBJECT_EXPRESS:
				sequence_ObjectExpress(context, (ObjectExpress) semanticObject); 
				return; 
			case SparrowPackage.OBJECT_EXPRESSION:
				sequence_ObjectExpression(context, (ObjectExpression) semanticObject); 
				return; 
			case SparrowPackage.OPERATE_LINK:
				sequence_OperateLink(context, (OperateLink) semanticObject); 
				return; 
			case SparrowPackage.OPERATION:
				sequence_Operation(context, (Operation) semanticObject); 
				return; 
			case SparrowPackage.OTHER_EXPRESSION:
				sequence_OtherExpression(context, (OtherExpression) semanticObject); 
				return; 
			case SparrowPackage.OTHER_MIX_EXPRESSION:
				sequence_OtherMixExpression(context, (OtherMixExpression) semanticObject); 
				return; 
			case SparrowPackage.PARALLEL_EXPRESSION:
				sequence_ParallelExpression(context, (ParallelExpression) semanticObject); 
				return; 
			case SparrowPackage.PERIOD_EXPRESSION:
				sequence_PeriodExpression(context, (PeriodExpression) semanticObject); 
				return; 
			case SparrowPackage.PERSON_EXPRESSION:
				sequence_PersonExpression(context, (PersonExpression) semanticObject); 
				return; 
			case SparrowPackage.REGULAR_RULE_EXPRESSION:
				sequence_RegularRuleExpression(context, (RegularRuleExpression) semanticObject); 
				return; 
			case SparrowPackage.REQUIRE:
				sequence_Require(context, (Require) semanticObject); 
				return; 
			case SparrowPackage.RIGHT:
				sequence_Right(context, (Right) semanticObject); 
				return; 
			case SparrowPackage.RULE_EXPRESSION:
				sequence_RuleExpression(context, (RuleExpression) semanticObject); 
				return; 
			case SparrowPackage.RULE_STRUCTURE:
				sequence_RuleStructure(context, (RuleStructure) semanticObject); 
				return; 
			case SparrowPackage.RULE_TIME_EXPRESSION:
				sequence_RuleTimeExpression(context, (RuleTimeExpression) semanticObject); 
				return; 
			case SparrowPackage.SINGLE_CONDITION:
				sequence_SingleCondition(context, (SingleCondition) semanticObject); 
				return; 
			case SparrowPackage.SINGLE_LINK_CONDITION:
				sequence_SingleLinkCondition(context, (SingleLinkCondition) semanticObject); 
				return; 
			case SparrowPackage.STRING_EXPRESSION:
				sequence_StringExpression(context, (StringExpression) semanticObject); 
				return; 
			case SparrowPackage.SUB_EXPRESSION:
				sequence_SubExpression(context, (SubExpression) semanticObject); 
				return; 
			case SparrowPackage.SUBJECT:
				sequence_Subject(context, (Subject) semanticObject); 
				return; 
			case SparrowPackage.SUBJECT_EXPRESS:
				sequence_SubjectExpress(context, (SubjectExpress) semanticObject); 
				return; 
			case SparrowPackage.SUBJECT_EXPRESSION:
				sequence_SubjectExpression(context, (SubjectExpression) semanticObject); 
				return; 
			case SparrowPackage.THEN_OPERATION:
				sequence_ThenOperation(context, (ThenOperation) semanticObject); 
				return; 
			case SparrowPackage.THIS_BOOLEAN:
				sequence_ThisBoolean(context, (ThisBoolean) semanticObject); 
				return; 
			case SparrowPackage.THIS_DATE:
				sequence_ThisDate(context, (ThisDate) semanticObject); 
				return; 
			case SparrowPackage.THIS_DECIMAL:
				sequence_ThisDecimal(context, (ThisDecimal) semanticObject); 
				return; 
			case SparrowPackage.THIS_STRING:
				sequence_ThisString(context, (ThisString) semanticObject); 
				return; 
			case SparrowPackage.TIME_SUB:
				sequence_TimeSub(context, (TimeSub) semanticObject); 
				return; 
			case SparrowPackage.TOTAL_CONDITION:
				sequence_TotalCondition(context, (TotalCondition) semanticObject); 
				return; 
			case SparrowPackage.TOTAL_EXPRESSION:
				sequence_TotalExpression(context, (TotalExpression) semanticObject); 
				return; 
			case SparrowPackage.TOTAL_OPERATION:
				sequence_TotalOperation(context, (TotalOperation) semanticObject); 
				return; 
			case SparrowPackage.WITHIN_POINT:
				sequence_WithinPoint(context, (WithinPoint) semanticObject); 
				return; 
			case SparrowPackage.CHANGE_ADDRESS:
				sequence_changeAddress(context, (changeAddress) semanticObject); 
				return; 
			case SparrowPackage.CHANGE_CONTRACT:
				sequence_changeContract(context, (changeContract) semanticObject); 
				return; 
			case SparrowPackage.CHANGE_OTHER:
				sequence_changeOther(context, (changeOther) semanticObject); 
				return; 
			case SparrowPackage.CHANGE_RULE:
				sequence_changeRule(context, (changeRule) semanticObject); 
				return; 
			case SparrowPackage.CHANGE_STRING:
				sequence_changeString(context, (changeString) semanticObject); 
				return; 
			case SparrowPackage.CHECK_EXPRESSION:
				sequence_checkExpression(context, (checkExpression) semanticObject); 
				return; 
			case SparrowPackage.EVERY_MESSAGE:
				sequence_everyMessage(context, (everyMessage) semanticObject); 
				return; 
			case SparrowPackage.INIT_EXPRESSIONO:
				sequence_initExpressiono(context, (initExpressiono) semanticObject); 
				return; 
			case SparrowPackage.INIT_EXPRESSIONS:
				sequence_initExpressions(context, (initExpressions) semanticObject); 
				return; 
			case SparrowPackage.IS_DONE:
				sequence_isDone(context, (isDone) semanticObject); 
				return; 
			case SparrowPackage.IS_TIME:
				sequence_isTime(context, (isTime) semanticObject); 
				return; 
			case SparrowPackage.IS_TRUE:
				sequence_isTrue(context, (isTrue) semanticObject); 
				return; 
			case SparrowPackage.KEYVALUE:
				sequence_keyvalue(context, (keyvalue) semanticObject); 
				return; 
			case SparrowPackage.LOGIC:
				sequence_logic(context, (logic) semanticObject); 
				return; 
			case SparrowPackage.MESSAGE_EXPRESSION:
				sequence_messageExpression(context, (messageExpression) semanticObject); 
				return; 
			case SparrowPackage.OTHERCHANGE:
				sequence_otherchange(context, (otherchange) semanticObject); 
				return; 
			case SparrowPackage.SET_DATE_EXPRESSION:
				sequence_setDateExpression(context, (setDateExpression) semanticObject); 
				return; 
			case SparrowPackage.TRANSFER_EXPRESSION:
				sequence_transferExpression(context, (transferExpression) semanticObject); 
				return; 
			case SparrowPackage.URL:
				sequence_url(context, (url) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     ManyRuleExpression returns AdditionExpression
	 *     AdditionExpression returns AdditionExpression
	 *
	 * Constraint:
	 *     (ruleExpression+=RuleExpression ruleExpression+=RuleExpression*)
	 * </pre>
	 */
	protected void sequence_AdditionExpression(ISerializationContext context, AdditionExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Value returns Address
	 *     Address returns Address
	 *
	 * Constraint:
	 *     value=STRING
	 * </pre>
	 */
	protected void sequence_Address(ISerializationContext context, Address semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.ADDRESS__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.ADDRESS__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAddressAccess().getValueSTRINGTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Value returns AllNumber
	 *     AllNumber returns AllNumber
	 *     SingleExpression returns AllNumber
	 *     RegularExpression returns AllNumber
	 *
	 * Constraint:
	 *     number=INT
	 * </pre>
	 */
	protected void sequence_AllNumber(ISerializationContext context, AllNumber semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.ALL_NUMBER__NUMBER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.ALL_NUMBER__NUMBER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAllNumberAccess().getNumberINTTerminalRuleCall_0(), semanticObject.getNumber());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AndOrCondition returns AndOrCondition
	 *
	 * Constraint:
	 *     ((link='and' | link='or') (condition=SingleCondition | linkCondition=SingleLinkCondition))
	 * </pre>
	 */
	protected void sequence_AndOrCondition(ISerializationContext context, AndOrCondition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AndOrOperationLink returns AndOrOperationLink
	 *
	 * Constraint:
	 *     (link='and' (firstOperation=trueOperation | linkOperation=[OperateLink|ID]))
	 * </pre>
	 */
	protected void sequence_AndOrOperationLink(ISerializationContext context, AndOrOperationLink semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Timepoint returns BeforePoint
	 *     BeforePoint returns BeforePoint
	 *     TrueCondition returns BeforePoint
	 *
	 * Constraint:
	 *     (lineTime=ThisDate | value=[keyvalue|ID])
	 * </pre>
	 */
	protected void sequence_BeforePoint(ISerializationContext context, BeforePoint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TrueCondition returns CompareString
	 *     CompareString returns CompareString
	 *
	 * Constraint:
	 *     (valueA=MixExpression valueB=MixExpression)
	 * </pre>
	 */
	protected void sequence_CompareString(ISerializationContext context, CompareString semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.COMPARE_STRING__VALUE_A) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.COMPARE_STRING__VALUE_A));
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.COMPARE_STRING__VALUE_B) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.COMPARE_STRING__VALUE_B));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompareStringAccess().getValueAMixExpressionParserRuleCall_1_0(), semanticObject.getValueA());
		feeder.accept(grammarAccess.getCompareStringAccess().getValueBMixExpressionParserRuleCall_3_0(), semanticObject.getValueB());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ConditionLink returns ConditionLink
	 *
	 * Constraint:
	 *     (name=ID (conditionExpression=SingleCondition | linkCondition=SingleLinkCondition)? andOrLink+=AndOrCondition*)
	 * </pre>
	 */
	protected void sequence_ConditionLink(ISerializationContext context, ConditionLink semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Condition returns Condition
	 *
	 * Constraint:
	 *     (conditions+=ConditionLink conditions+=ConditionLink*)
	 * </pre>
	 */
	protected void sequence_Condition(ISerializationContext context, Condition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ContractMessage returns ContractMessage
	 *
	 * Constraint:
	 *     (message+=Message message+=Message*)
	 * </pre>
	 */
	protected void sequence_ContractMessage(ISerializationContext context, ContractMessage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DATE returns DATE
	 *
	 * Constraint:
	 *     (year=INT month=INT day=INT hour=INT min=INT)
	 * </pre>
	 */
	protected void sequence_DATE(ISerializationContext context, DATE semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.DATE__YEAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.DATE__YEAR));
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.DATE__MONTH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.DATE__MONTH));
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.DATE__DAY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.DATE__DAY));
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.DATE__HOUR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.DATE__HOUR));
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.DATE__MIN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.DATE__MIN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDATEAccess().getYearINTTerminalRuleCall_0_0(), semanticObject.getYear());
		feeder.accept(grammarAccess.getDATEAccess().getMonthINTTerminalRuleCall_2_0(), semanticObject.getMonth());
		feeder.accept(grammarAccess.getDATEAccess().getDayINTTerminalRuleCall_4_0(), semanticObject.getDay());
		feeder.accept(grammarAccess.getDATEAccess().getHourINTTerminalRuleCall_6_0(), semanticObject.getHour());
		feeder.accept(grammarAccess.getDATEAccess().getMinINTTerminalRuleCall_8_0(), semanticObject.getMin());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Value returns Duration
	 *     Duration returns Duration
	 *
	 * Constraint:
	 *     (value=INT (symbol='years' | symbol='months' | symbol='days' | symbol='hours' | symbol='mins'))
	 * </pre>
	 */
	protected void sequence_Duration(ISerializationContext context, Duration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ElseExpression returns ElseExpression
	 *
	 * Constraint:
	 *     (set=messageExpression? totalCondition=TotalCondition? totalOperation=TotalOperation)
	 * </pre>
	 */
	protected void sequence_ElseExpression(ISerializationContext context, ElseExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ManyRuleExpression returns ExclusiveExpression
	 *     ExclusiveExpression returns ExclusiveExpression
	 *
	 * Constraint:
	 *     (ruleExpression+=RuleExpression ruleExpression+=RuleExpression*)
	 * </pre>
	 */
	protected void sequence_ExclusiveExpression(ISerializationContext context, ExclusiveExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FailResult returns FailResult
	 *
	 * Constraint:
	 *     (
	 *         (followingOperation=trueOperation | linkOperation=[OperateLink|ID]) 
	 *         andor+=AndOrOperationLink* 
	 *         timePoint=Timepoint? 
	 *         thenoperation+=ThenOperation*
	 *     )
	 * </pre>
	 */
	protected void sequence_FailResult(ISerializationContext context, FailResult semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SingleExpression returns FloatExpression
	 *     FloatExpression returns FloatExpression
	 *
	 * Constraint:
	 *     value=ID
	 * </pre>
	 */
	protected void sequence_FloatExpression(ISerializationContext context, FloatExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.FLOAT_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.FLOAT_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFloatExpressionAccess().getValueIDTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SingleExpression returns GetPeriodExpression
	 *     GetPeriodExpression returns GetPeriodExpression
	 *
	 * Constraint:
	 *     (value=ID type=EachTime)
	 * </pre>
	 */
	protected void sequence_GetPeriodExpression(ISerializationContext context, GetPeriodExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.GET_PERIOD_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.GET_PERIOD_EXPRESSION__VALUE));
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.GET_PERIOD_EXPRESSION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.GET_PERIOD_EXPRESSION__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGetPeriodExpressionAccess().getValueIDTerminalRuleCall_0_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getGetPeriodExpressionAccess().getTypeEachTimeParserRuleCall_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Group returns Group
	 *
	 * Constraint:
	 *     (subtype=[Subject|ID] name=ID value+=[initExpressions|ID] value+=[initExpressions|ID]*)
	 * </pre>
	 */
	protected void sequence_Group(ISerializationContext context, Group semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Initialize returns Initialize
	 *
	 * Constraint:
	 *     (inits+=initExpressions* inito+=initExpressiono*)
	 * </pre>
	 */
	protected void sequence_Initialize(ISerializationContext context, Initialize semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Message returns Message
	 *
	 * Constraint:
	 *     (type=keyvalue value=Value)
	 * </pre>
	 */
	protected void sequence_Message(ISerializationContext context, Message semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.MESSAGE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.MESSAGE__TYPE));
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.MESSAGE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.MESSAGE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMessageAccess().getTypeKeyvalueParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getMessageAccess().getValueValueParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MixExpression returns MixExpression
	 *
	 * Constraint:
	 *     (expression=SingleExpression otherMixExpression+=OtherMixExpression*)
	 * </pre>
	 */
	protected void sequence_MixExpression(ISerializationContext context, MixExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (
	 *         packageName+=ID* 
	 *         name=ID 
	 *         extendName=ID? 
	 *         subjects+=Subject* 
	 *         objects+=Object* 
	 *         group+=Group* 
	 *         initialize=Initialize? 
	 *         contractMessage=ContractMessage? 
	 *         Conditions=Condition? 
	 *         operations=Operation? 
	 *         ruleStructures=RuleStructure? 
	 *         require=Require?
	 *     )
	 * </pre>
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Value returns Now
	 *     Now returns Now
	 *     SingleExpression returns Now
	 *     RegularExpression returns Now
	 *
	 * Constraint:
	 *     value='now'
	 * </pre>
	 */
	protected void sequence_Now(ISerializationContext context, Now semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.NOW__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.NOW__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNowAccess().getValueNowKeyword_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SingleExpression returns ObjectExpress
	 *     ThingExpression returns ObjectExpress
	 *     ObjectExpress returns ObjectExpress
	 *
	 * Constraint:
	 *     (object=[initExpressiono|ID] attribute=ID)
	 * </pre>
	 */
	protected void sequence_ObjectExpress(ISerializationContext context, ObjectExpress semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.OBJECT_EXPRESS__OBJECT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.OBJECT_EXPRESS__OBJECT));
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.THING_EXPRESSION__ATTRIBUTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.THING_EXPRESSION__ATTRIBUTE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getObjectExpressAccess().getObjectInitExpressionoIDTerminalRuleCall_1_0_1(), semanticObject.eGet(SparrowPackage.Literals.OBJECT_EXPRESS__OBJECT, false));
		feeder.accept(grammarAccess.getObjectExpressAccess().getAttributeIDTerminalRuleCall_3_0(), semanticObject.getAttribute());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ObjectExpression returns ObjectExpression
	 *
	 * Constraint:
	 *     (keyValue+=keyvalue keyValue+=keyvalue*)
	 * </pre>
	 */
	protected void sequence_ObjectExpression(ISerializationContext context, ObjectExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Object returns Object
	 *
	 * Constraint:
	 *     (name=ID objectExpression=ObjectExpression)
	 * </pre>
	 */
	protected void sequence_Object(ISerializationContext context, org.xtext.example.mydsl.sparrow.Object semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.OBJECT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.OBJECT__NAME));
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.OBJECT__OBJECT_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.OBJECT__OBJECT_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getObjectAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getObjectAccess().getObjectExpressionObjectExpressionParserRuleCall_2_0(), semanticObject.getObjectExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OperateLink returns OperateLink
	 *
	 * Constraint:
	 *     (name=ID (firstOperation=trueOperation | linkOperation=[OperateLink|ID]) andOrLink+=AndOrOperationLink*)
	 * </pre>
	 */
	protected void sequence_OperateLink(ISerializationContext context, OperateLink semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Operation returns Operation
	 *
	 * Constraint:
	 *     (operates+=OperateLink operates+=OperateLink*)
	 * </pre>
	 */
	protected void sequence_Operation(ISerializationContext context, Operation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SingleExpression returns OtherExpression
	 *     OtherExpression returns OtherExpression
	 *
	 * Constraint:
	 *     value=ID
	 * </pre>
	 */
	protected void sequence_OtherExpression(ISerializationContext context, OtherExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.OTHER_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.OTHER_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOtherExpressionAccess().getValueIDTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OtherMixExpression returns OtherMixExpression
	 *
	 * Constraint:
	 *     (link=ARITHMETIC_OPERATOR expression=SingleExpression)
	 * </pre>
	 */
	protected void sequence_OtherMixExpression(ISerializationContext context, OtherMixExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.OTHER_MIX_EXPRESSION__LINK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.OTHER_MIX_EXPRESSION__LINK));
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.OTHER_MIX_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.OTHER_MIX_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOtherMixExpressionAccess().getLinkARITHMETIC_OPERATORTerminalRuleCall_0_0(), semanticObject.getLink());
		feeder.accept(grammarAccess.getOtherMixExpressionAccess().getExpressionSingleExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ManyRuleExpression returns ParallelExpression
	 *     ParallelExpression returns ParallelExpression
	 *
	 * Constraint:
	 *     (ruleExpression+=RuleExpression ruleExpression+=RuleExpression*)
	 * </pre>
	 */
	protected void sequence_ParallelExpression(ISerializationContext context, ParallelExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SingleExpression returns PeriodExpression
	 *     PeriodExpression returns PeriodExpression
	 *
	 * Constraint:
	 *     (value=INT type=EachTime)
	 * </pre>
	 */
	protected void sequence_PeriodExpression(ISerializationContext context, PeriodExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.PERIOD_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.PERIOD_EXPRESSION__VALUE));
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.PERIOD_EXPRESSION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.PERIOD_EXPRESSION__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPeriodExpressionAccess().getValueINTTerminalRuleCall_0_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getPeriodExpressionAccess().getTypeEachTimeParserRuleCall_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SingleExpression returns PersonExpression
	 *     PersonExpression returns PersonExpression
	 *
	 * Constraint:
	 *     value=[initExpressions|ID]
	 * </pre>
	 */
	protected void sequence_PersonExpression(ISerializationContext context, PersonExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.PERSON_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.PERSON_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPersonExpressionAccess().getValueInitExpressionsIDTerminalRuleCall_1_0_1(), semanticObject.eGet(SparrowPackage.Literals.PERSON_EXPRESSION__VALUE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ManyRuleExpression returns RegularRuleExpression
	 *     RegularRuleExpression returns RegularRuleExpression
	 *
	 * Constraint:
	 *     (ruleExpression+=RuleExpression ruleExpression+=RuleExpression*)
	 * </pre>
	 */
	protected void sequence_RegularRuleExpression(ISerializationContext context, RegularRuleExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Require returns Require
	 *
	 * Constraint:
	 *     ((value+=conditiontype | value+=actiontype) value+=conditiontype? (value+=actiontype? value+=conditiontype?)*)
	 * </pre>
	 */
	protected void sequence_Require(ISerializationContext context, Require semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Value returns Right
	 *     Right returns Right
	 *
	 * Constraint:
	 *     right=[initExpressions|ID]
	 * </pre>
	 */
	protected void sequence_Right(ISerializationContext context, Right semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.RIGHT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.RIGHT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRightAccess().getRightInitExpressionsIDTerminalRuleCall_0_1(), semanticObject.eGet(SparrowPackage.Literals.RIGHT__RIGHT, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RuleExpression returns RuleExpression
	 *
	 * Constraint:
	 *     (
	 *         repeat='Repeat'? 
	 *         name=ID 
	 *         set=messageExpression? 
	 *         setdate=setDateExpression? 
	 *         totalCondition=TotalCondition? 
	 *         totalOperation=TotalOperation 
	 *         subExpression+=SubExpression* 
	 *         elseExpression=ElseExpression?
	 *     )
	 * </pre>
	 */
	protected void sequence_RuleExpression(ISerializationContext context, RuleExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RuleStructure returns RuleStructure
	 *
	 * Constraint:
	 *     manyRuleExpression+=ManyRuleExpression+
	 * </pre>
	 */
	protected void sequence_RuleStructure(ISerializationContext context, RuleStructure semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SingleExpression returns RuleTimeExpression
	 *     RuleTimeExpression returns RuleTimeExpression
	 *
	 * Constraint:
	 *     value=[RuleExpression|ID]
	 * </pre>
	 */
	protected void sequence_RuleTimeExpression(ISerializationContext context, RuleTimeExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.RULE_TIME_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.RULE_TIME_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRuleTimeExpressionAccess().getValueRuleExpressionIDTerminalRuleCall_1_0_1(), semanticObject.eGet(SparrowPackage.Literals.RULE_TIME_EXPRESSION__VALUE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SingleCondition returns SingleCondition
	 *
	 * Constraint:
	 *     (no='!'? condition=TrueCondition)
	 * </pre>
	 */
	protected void sequence_SingleCondition(ISerializationContext context, SingleCondition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SingleLinkCondition returns SingleLinkCondition
	 *
	 * Constraint:
	 *     (no='!'? linkCondition=[ConditionLink|ID])
	 * </pre>
	 */
	protected void sequence_SingleLinkCondition(ISerializationContext context, SingleLinkCondition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SingleExpression returns StringExpression
	 *     StringExpression returns StringExpression
	 *
	 * Constraint:
	 *     value=ID
	 * </pre>
	 */
	protected void sequence_StringExpression(ISerializationContext context, StringExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.STRING_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.STRING_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringExpressionAccess().getValueIDTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SubExpression returns SubExpression
	 *
	 * Constraint:
	 *     totalExpression=TotalExpression
	 * </pre>
	 */
	protected void sequence_SubExpression(ISerializationContext context, SubExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.SUB_EXPRESSION__TOTAL_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.SUB_EXPRESSION__TOTAL_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSubExpressionAccess().getTotalExpressionTotalExpressionParserRuleCall_2_0(), semanticObject.getTotalExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SingleExpression returns SubjectExpress
	 *     ThingExpression returns SubjectExpress
	 *     SubjectExpress returns SubjectExpress
	 *
	 * Constraint:
	 *     (subject=[initExpressions|ID] attribute=ID)
	 * </pre>
	 */
	protected void sequence_SubjectExpress(ISerializationContext context, SubjectExpress semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.SUBJECT_EXPRESS__SUBJECT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.SUBJECT_EXPRESS__SUBJECT));
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.THING_EXPRESSION__ATTRIBUTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.THING_EXPRESSION__ATTRIBUTE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSubjectExpressAccess().getSubjectInitExpressionsIDTerminalRuleCall_1_0_1(), semanticObject.eGet(SparrowPackage.Literals.SUBJECT_EXPRESS__SUBJECT, false));
		feeder.accept(grammarAccess.getSubjectExpressAccess().getAttributeIDTerminalRuleCall_3_0(), semanticObject.getAttribute());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SubjectExpression returns SubjectExpression
	 *
	 * Constraint:
	 *     (keyValue+=keyvalue keyValue+=keyvalue*)
	 * </pre>
	 */
	protected void sequence_SubjectExpression(ISerializationContext context, SubjectExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Subject returns Subject
	 *
	 * Constraint:
	 *     ((type='RA' | type='AA' | type='CA' | type='PA') name=ID subjectExpression=SubjectExpression?)
	 * </pre>
	 */
	protected void sequence_Subject(ISerializationContext context, Subject semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ThenOperation returns ThenOperation
	 *
	 * Constraint:
	 *     ((followingOperation=trueOperation | linkOperation=[OperateLink|ID]) andor+=AndOrOperationLink* timePoint=Timepoint? failresult=FailResult?)
	 * </pre>
	 */
	protected void sequence_ThenOperation(ISerializationContext context, ThenOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Value returns ThisBoolean
	 *     ThisBoolean returns ThisBoolean
	 *     SingleExpression returns ThisBoolean
	 *     RegularExpression returns ThisBoolean
	 *
	 * Constraint:
	 *     value=BOOLEAN
	 * </pre>
	 */
	protected void sequence_ThisBoolean(ISerializationContext context, ThisBoolean semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.THIS_BOOLEAN__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.THIS_BOOLEAN__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getThisBooleanAccess().getValueBOOLEANParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Value returns ThisDate
	 *     ThisDate returns ThisDate
	 *     SingleExpression returns ThisDate
	 *     RegularExpression returns ThisDate
	 *
	 * Constraint:
	 *     value=DATE
	 * </pre>
	 */
	protected void sequence_ThisDate(ISerializationContext context, ThisDate semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.THIS_DATE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.THIS_DATE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getThisDateAccess().getValueDATEParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Value returns ThisDecimal
	 *     ThisDecimal returns ThisDecimal
	 *     SingleExpression returns ThisDecimal
	 *     RegularExpression returns ThisDecimal
	 *
	 * Constraint:
	 *     value=DECIMAL
	 * </pre>
	 */
	protected void sequence_ThisDecimal(ISerializationContext context, ThisDecimal semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.THIS_DECIMAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.THIS_DECIMAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getThisDecimalAccess().getValueDECIMALTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Value returns ThisString
	 *     ThisString returns ThisString
	 *
	 * Constraint:
	 *     value=STRING
	 * </pre>
	 */
	protected void sequence_ThisString(ISerializationContext context, ThisString semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.THIS_STRING__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.THIS_STRING__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getThisStringAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TrueCondition returns TimeSub
	 *     TimeSub returns TimeSub
	 *
	 * Constraint:
	 *     (valueA=MixExpression valueB=MixExpression? valueC=[RuleExpression|ID]? duration=Duration compare=MATH_SYMBOL)
	 * </pre>
	 */
	protected void sequence_TimeSub(ISerializationContext context, TimeSub semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TotalCondition returns TotalCondition
	 *
	 * Constraint:
	 *     ((condition=SingleCondition | linkCondition=SingleLinkCondition) andorcondition+=AndOrCondition*)
	 * </pre>
	 */
	protected void sequence_TotalCondition(ISerializationContext context, TotalCondition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TotalExpression returns TotalExpression
	 *
	 * Constraint:
	 *     (set=messageExpression? totalCondition=TotalCondition? totalOperation=TotalOperation elseExpression=ElseExpression?)
	 * </pre>
	 */
	protected void sequence_TotalExpression(ISerializationContext context, TotalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TotalOperation returns TotalOperation
	 *
	 * Constraint:
	 *     (
	 *         person=[initExpressions|ID]? 
	 *         person2=[Group|ID]? 
	 *         (firstOperation=trueOperation | linkOperation=[OperateLink|ID])? 
	 *         andor+=AndOrOperationLink* 
	 *         timePoint=Timepoint? 
	 *         failresult=FailResult? 
	 *         thenoperation+=ThenOperation*
	 *     )
	 * </pre>
	 */
	protected void sequence_TotalOperation(ISerializationContext context, TotalOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Timepoint returns WithinPoint
	 *     WithinPoint returns WithinPoint
	 *     TrueCondition returns WithinPoint
	 *
	 * Constraint:
	 *     (number=INT time=EachTime thing=[RuleExpression|ID])
	 * </pre>
	 */
	protected void sequence_WithinPoint(ISerializationContext context, WithinPoint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.WITHIN_POINT__NUMBER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.WITHIN_POINT__NUMBER));
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.WITHIN_POINT__TIME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.WITHIN_POINT__TIME));
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.WITHIN_POINT__THING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.WITHIN_POINT__THING));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWithinPointAccess().getNumberINTTerminalRuleCall_1_0(), semanticObject.getNumber());
		feeder.accept(grammarAccess.getWithinPointAccess().getTimeEachTimeParserRuleCall_2_0(), semanticObject.getTime());
		feeder.accept(grammarAccess.getWithinPointAccess().getThingRuleExpressionIDTerminalRuleCall_4_0_1(), semanticObject.eGet(SparrowPackage.Literals.WITHIN_POINT__THING, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     trueOperation returns changeAddress
	 *     changeExpression returns changeAddress
	 *     changeAddress returns changeAddress
	 *
	 * Constraint:
	 *     (changeThing=MixExpression changeResult=MixExpression)
	 * </pre>
	 */
	protected void sequence_changeAddress(ISerializationContext context, changeAddress semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.CHANGE_ADDRESS__CHANGE_THING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.CHANGE_ADDRESS__CHANGE_THING));
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.CHANGE_ADDRESS__CHANGE_RESULT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.CHANGE_ADDRESS__CHANGE_RESULT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getChangeAddressAccess().getChangeThingMixExpressionParserRuleCall_1_0(), semanticObject.getChangeThing());
		feeder.accept(grammarAccess.getChangeAddressAccess().getChangeResultMixExpressionParserRuleCall_4_0(), semanticObject.getChangeResult());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     trueOperation returns changeContract
	 *     changeExpression returns changeContract
	 *     changeContract returns changeContract
	 *
	 * Constraint:
	 *     changeResult=ContractState
	 * </pre>
	 */
	protected void sequence_changeContract(ISerializationContext context, changeContract semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.CHANGE_CONTRACT__CHANGE_RESULT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.CHANGE_CONTRACT__CHANGE_RESULT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getChangeContractAccess().getChangeResultContractStateParserRuleCall_3_0(), semanticObject.getChangeResult());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     trueOperation returns changeOther
	 *     changeExpression returns changeOther
	 *     changeOther returns changeOther
	 *
	 * Constraint:
	 *     (changeThing=SingleExpression changeResult=BOOLEAN)
	 * </pre>
	 */
	protected void sequence_changeOther(ISerializationContext context, changeOther semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.CHANGE_OTHER__CHANGE_THING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.CHANGE_OTHER__CHANGE_THING));
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.CHANGE_OTHER__CHANGE_RESULT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.CHANGE_OTHER__CHANGE_RESULT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getChangeOtherAccess().getChangeThingSingleExpressionParserRuleCall_2_0(), semanticObject.getChangeThing());
		feeder.accept(grammarAccess.getChangeOtherAccess().getChangeResultBOOLEANParserRuleCall_4_0(), semanticObject.getChangeResult());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     trueOperation returns changeRule
	 *     changeExpression returns changeRule
	 *     changeRule returns changeRule
	 *
	 * Constraint:
	 *     (changeThing=[RuleExpression|ID] changeResult=BOOLEAN)
	 * </pre>
	 */
	protected void sequence_changeRule(ISerializationContext context, changeRule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.CHANGE_RULE__CHANGE_THING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.CHANGE_RULE__CHANGE_THING));
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.CHANGE_RULE__CHANGE_RESULT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.CHANGE_RULE__CHANGE_RESULT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getChangeRuleAccess().getChangeThingRuleExpressionIDTerminalRuleCall_1_0_1(), semanticObject.eGet(SparrowPackage.Literals.CHANGE_RULE__CHANGE_THING, false));
		feeder.accept(grammarAccess.getChangeRuleAccess().getChangeResultBOOLEANParserRuleCall_3_0(), semanticObject.getChangeResult());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     trueOperation returns changeString
	 *     changeExpression returns changeString
	 *     changeString returns changeString
	 *
	 * Constraint:
	 *     (changeThing=MixExpression changeResult=MixExpression)
	 * </pre>
	 */
	protected void sequence_changeString(ISerializationContext context, changeString semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.CHANGE_STRING__CHANGE_THING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.CHANGE_STRING__CHANGE_THING));
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.CHANGE_STRING__CHANGE_RESULT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.CHANGE_STRING__CHANGE_RESULT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getChangeStringAccess().getChangeThingMixExpressionParserRuleCall_1_0(), semanticObject.getChangeThing());
		feeder.accept(grammarAccess.getChangeStringAccess().getChangeResultMixExpressionParserRuleCall_3_0(), semanticObject.getChangeResult());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TrueCondition returns checkExpression
	 *     checkExpression returns checkExpression
	 *
	 * Constraint:
	 *     name=[Model|ID]
	 * </pre>
	 */
	protected void sequence_checkExpression(ISerializationContext context, checkExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.CHECK_EXPRESSION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.CHECK_EXPRESSION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCheckExpressionAccess().getNameModelIDTerminalRuleCall_1_0_1(), semanticObject.eGet(SparrowPackage.Literals.CHECK_EXPRESSION__NAME, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     everyMessage returns everyMessage
	 *
	 * Constraint:
	 *     (symbol='new'? type=type message=ID)
	 * </pre>
	 */
	protected void sequence_everyMessage(ISerializationContext context, everyMessage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     initExpressiono returns initExpressiono
	 *
	 * Constraint:
	 *     (obtype=[Object|ID] name=ID value+=Value value+=Value*)
	 * </pre>
	 */
	protected void sequence_initExpressiono(ISerializationContext context, initExpressiono semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     initExpressions returns initExpressions
	 *
	 * Constraint:
	 *     (subtype=[Subject|ID] name=ID value+=Value value+=Value*)
	 * </pre>
	 */
	protected void sequence_initExpressions(ISerializationContext context, initExpressions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TrueCondition returns isDone
	 *     isDone returns isDone
	 *
	 * Constraint:
	 *     name=[RuleExpression|ID]
	 * </pre>
	 */
	protected void sequence_isDone(ISerializationContext context, isDone semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.IS_DONE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.IS_DONE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIsDoneAccess().getNameRuleExpressionIDTerminalRuleCall_1_0_1(), semanticObject.eGet(SparrowPackage.Literals.IS_DONE__NAME, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TrueCondition returns isTime
	 *     isTime returns isTime
	 *
	 * Constraint:
	 *     (expression=MixExpression? value=[RuleExpression|ID]? (symbol=ARITHMETIC_OPERATOR duration=Duration)?)
	 * </pre>
	 */
	protected void sequence_isTime(ISerializationContext context, isTime semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TrueCondition returns isTrue
	 *     isTrue returns isTrue
	 *
	 * Constraint:
	 *     compare=SingleExpression
	 * </pre>
	 */
	protected void sequence_isTrue(ISerializationContext context, isTrue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.IS_TRUE__COMPARE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.IS_TRUE__COMPARE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIsTrueAccess().getCompareSingleExpressionParserRuleCall_1_0(), semanticObject.getCompare());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     keyvalue returns keyvalue
	 *
	 * Constraint:
	 *     (type=type name=ID)
	 * </pre>
	 */
	protected void sequence_keyvalue(ISerializationContext context, keyvalue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.KEYVALUE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.KEYVALUE__TYPE));
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.KEYVALUE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.KEYVALUE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getKeyvalueAccess().getTypeTypeParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getKeyvalueAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TrueCondition returns logic
	 *     logic returns logic
	 *
	 * Constraint:
	 *     (valueA=MixExpression valueB=MixExpression mathSymbol=MATH_SYMBOL)
	 * </pre>
	 */
	protected void sequence_logic(ISerializationContext context, logic semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.LOGIC__VALUE_A) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.LOGIC__VALUE_A));
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.LOGIC__VALUE_B) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.LOGIC__VALUE_B));
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.LOGIC__MATH_SYMBOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.LOGIC__MATH_SYMBOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogicAccess().getValueAMixExpressionParserRuleCall_1_0(), semanticObject.getValueA());
		feeder.accept(grammarAccess.getLogicAccess().getValueBMixExpressionParserRuleCall_3_0(), semanticObject.getValueB());
		feeder.accept(grammarAccess.getLogicAccess().getMathSymbolMATH_SYMBOLTerminalRuleCall_5_0(), semanticObject.getMathSymbol());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     messageExpression returns messageExpression
	 *
	 * Constraint:
	 *     (everymassage+=everyMessage everymassage+=everyMessage*)
	 * </pre>
	 */
	protected void sequence_messageExpression(ISerializationContext context, messageExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     trueOperation returns otherchange
	 *     changeExpression returns otherchange
	 *     otherchange returns otherchange
	 *
	 * Constraint:
	 *     (changeThing=MixExpression changeResult=MixExpression)
	 * </pre>
	 */
	protected void sequence_otherchange(ISerializationContext context, otherchange semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.OTHERCHANGE__CHANGE_THING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.OTHERCHANGE__CHANGE_THING));
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.OTHERCHANGE__CHANGE_RESULT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.OTHERCHANGE__CHANGE_RESULT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOtherchangeAccess().getChangeThingMixExpressionParserRuleCall_1_0(), semanticObject.getChangeThing());
		feeder.accept(grammarAccess.getOtherchangeAccess().getChangeResultMixExpressionParserRuleCall_3_0(), semanticObject.getChangeResult());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     setDateExpression returns setDateExpression
	 *
	 * Constraint:
	 *     message=ID
	 * </pre>
	 */
	protected void sequence_setDateExpression(ISerializationContext context, setDateExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.SET_DATE_EXPRESSION__MESSAGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.SET_DATE_EXPRESSION__MESSAGE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSetDateExpressionAccess().getMessageIDTerminalRuleCall_1_0(), semanticObject.getMessage());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     trueOperation returns transferExpression
	 *     transferExpression returns transferExpression
	 *
	 * Constraint:
	 *     (person=[initExpressions|ID] value=MixExpression)
	 * </pre>
	 */
	protected void sequence_transferExpression(ISerializationContext context, transferExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.TRANSFER_EXPRESSION__PERSON) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.TRANSFER_EXPRESSION__PERSON));
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.TRANSFER_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.TRANSFER_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTransferExpressionAccess().getPersonInitExpressionsIDTerminalRuleCall_1_0_1(), semanticObject.eGet(SparrowPackage.Literals.TRANSFER_EXPRESSION__PERSON, false));
		feeder.accept(grammarAccess.getTransferExpressionAccess().getValueMixExpressionParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Value returns url
	 *     url returns url
	 *
	 * Constraint:
	 *     value=URL_STRING
	 * </pre>
	 */
	protected void sequence_url(ISerializationContext context, url semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SparrowPackage.Literals.URL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SparrowPackage.Literals.URL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUrlAccess().getValueURL_STRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
}
